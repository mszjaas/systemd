From 823c1e98f9efa96aa9ce52b2ffce061a68b7dece Mon Sep 17 00:00:00 2001
From: rpm-build <rpm-build>
Date: Sat, 28 Jun 2025 12:04:16 +0800
Subject: [PATCH] shutdown: extract timeout wrapper

---
 src/shutdown/umount.c | 54 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 54 insertions(+)

diff --git a/src/shutdown/umount.c b/src/shutdown/umount.c
index 220ae2e..1da00fb 100644
--- a/src/shutdown/umount.c
+++ b/src/shutdown/umount.c
@@ -30,6 +30,10 @@
 #include "virt.h"
 #include "manager.h"
 
+typedef int (*TimeoutTask)(MountPoint *m, bool last_try);
+static int shutdown_timeout_wrapper(const char* task_name, const char* task_note,
+                                    TimeoutTask func, MountPoint *m, bool last_try);
+
 static void mount_point_free(MountPoint **head, MountPoint *m) {
         assert(head);
         assert(m);
@@ -497,3 +501,53 @@ int umount_all(bool *changed, bool last_try) {
 
         return r;
 }
+
+static int shutdown_timeout_wrapper(const char* task_name, const char* task_note,
+                                    TimeoutTask func, MountPoint *m, bool last_try)
+{
+        _cleanup_close_pair_ int pfd[2] = EBADF_PAIR;
+        _cleanup_(sigkill_nowaitp) pid_t pid = 0;
+        int r;
+
+        BLOCK_SIGNALS(SIGCHLD);
+
+        assert(m);
+
+        r = pipe2(pfd, O_CLOEXEC|O_NONBLOCK);
+        if (r < 0)
+                return r;
+
+        /* Due to the possibility of a remount operation hanging, we fork a child process and set a
+         * timeout. If the timeout lapses, the assumption is that the particular remount failed. */
+        r = safe_fork_full(task_name,
+                           NULL,
+                           pfd, ELEMENTSOF(pfd),
+                           FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_LOG|FORK_REOPEN_LOG, &pid);
+        if (r < 0)
+                return r;
+        if (r == 0) {
+                pfd[0] = safe_close(pfd[0]);
+
+                r = func(m, last_try);
+
+                (void) write(pfd[1], &r, sizeof(r)); /* try to send errno up */
+                _exit(r < 0 ? EXIT_FAILURE : EXIT_SUCCESS);
+        }
+
+        pfd[1] = safe_close(pfd[1]);
+
+        r = wait_for_terminate_with_timeout(pid, DEFAULT_TIMEOUT_USEC);
+        if (r == -ETIMEDOUT)
+                log_error_errno(r, "%s  '%s' timed out, issuing SIGKILL to PID " PID_FMT ".", task_note, m->path, pid);
+        else if (r == -EPROTO) {
+                /* Try to read error code from child */
+                if (read(pfd[0], &r, sizeof(r)) == sizeof(r))
+                        log_debug_errno(r, "%s '%s' failed abnormally, child process " PID_FMT " failed: %m", task_note, m->path, pid);
+                else
+                        r = log_debug_errno(EPROTO, "%s '%s' failed abnormally, child process " PID_FMT " aborted or exited non-zero.", task_note, m->path, pid);
+                TAKE_PID(pid); /* child exited (just not as we expected) hence don't kill anymore */
+        } else if (r < 0)
+                log_error_errno(r, "%s '%s' failed unexpectedly, couldn't wait for child process " PID_FMT ": %m", task_note, m->path, pid);
+
+        return r;
+}
-- 
2.43.0

